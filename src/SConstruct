# -*- mode: python -*-

import os

EnsureSConsVersion(1, 2)

## helper for the symlink targets ##########
def AddSOSymlinkTargetAction(env, targetTrigger, addCleanTarget=True):
    # add postAction to create symlinks
    if env['PLATFORM'] == "posix":
        ## add a postaction to create symbolic links, when
        ## you build a shared library at a unix/linux system
        major = env['MAJOR_VERSION']
        minor = env['MINOR_VERSION']
        patch = env['REVISION_VERSION']

        def create_or_update_symlink(src, dst):
            if os.path.exists(dst):
                if os.path.islink(dst):
                    os.unlink(dst)
            os.symlink(src, dst)

        def createSOLinks (target=None, source=None, env=None):
            libpath = File(target[0]).abspath
            lib = os.path.basename(libpath)
            link2 = lib[0:lib.rindex('.%d' % patch)]
            link1 = link2[0:link2.rindex('.%d' % minor)]
            link0 = link1[0:link1.rindex('.%d' % major)]

            cwd = os.getcwd()
            os.chdir(Dir('%s' % libpath[0:libpath.rindex(os.path.sep)]).abspath)
            try:
                create_or_update_symlink(lib, link2)
                create_or_update_symlink(lib, link1)
                create_or_update_symlink(lib, link0)
            finally:
                os.chdir(cwd)

        env.AddPostAction(targetTrigger, Action(createSOLinks))

        ## add additional cleanup targets for the links
        ## FIXME: doesn't work currently, because symlinks
        ##        are not a valid Clean target for scons
        if addCleanTarget:
            libpath = File(targetTrigger[0]).abspath
            lib   = os.path.basename(libpath)
            link2 = lib[0:lib.rindex('.%d' % patch)]
            link1 = link2[0:link2.rindex('.%d' % minor)]
            link0 = link1[0:link1.rindex('.%d' % major)]

            libdir = Dir(libpath[0:libpath.rindex(os.path.sep)]).abspath
            lnk0 = File(os.path.join(libdir, link0)).abspath
            lnk1 = File(os.path.join(libdir, link1)).abspath
            lnk2 = File(os.path.join(libdir, link2)).abspath
            env.Clean(targetTrigger, [lnk0, lnk1, lnk2])


Export ('AddSOSymlinkTargetAction')


env = Environment(CPPPATH=[".", ".."], CPPDEFINES="DEBUG", CPPFLAGS="--param inline-unit-growth=500 --param large-function-growth=5000 --param max-inline-insns-single=5000 -Wall -Wctor-dtor-privacy -Wstrict-null-sentinel -Woverloaded-virtual -Wextra -Wunused -Wswitch -Wreorder -Wformat-y2k -Wformat-security -Wuninitialized -Winit-self -Wmissing-include-dirs -Wswitch-enum -Wfloat-equal -ggdb -O2",
                  MAJOR_VERSION=0,
                  MINOR_VERSION=1,
                  REVISION_VERSION=0)

conf = Configure(env)

for hdr in ('loki/TypeTraits.h', 'boost/lexical_cast.hpp',
            'boost/test/unit_test.hpp', 'boost/test/unit_test_log.hpp',
            'boost/test/unit_test_monitor.hpp',
            'boost/test/impl/unit_test_main.ipp',
            'boost/test/impl/framework.ipp'):
    if not conf.CheckCXXHeader(hdr):
        print "We need C++ header %s." % hdr
        Exit(1)

for lib in ('loki', 'boost_unit_test_framework-mt'):
    if not conf.CheckLib(lib, language="C++"):
        print "We need C++ library %s" % lib
        Exit(1)

env = conf.Finish()
env.Decider("timestamp-newer")

DESTDIR=os.getenv("DESTDIR")
if not DESTDIR:
    DESTDIR=os.path.join(os.getcwd(), "build")
PREFIX=Dir(DESTDIR).abspath

Export(Split('env PREFIX'))

SConscript('egen/SConscript')
SConscript('test/SConscript')

env.Clean('build', 'config.log')
